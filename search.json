[{"title":"Ubuntu","url":"/2022/04/30/Ubuntu%E7%B3%BB%E7%BB%9F/","content":"Ubuntu系统1.1.1.文件系统linux,使用统一的目录树结构\n//home/niudada/root/bin/mnt/usr/etc\n\n注意：linux下没有C:D:盘符的概念\n1.2.用户目录/home/niudada 称为niudada的用户目录linux系统支持多个用户，每个用户一个目录都有一个超级用户root，其用户目录为/rootroot用户没有限制，可以操作任意文件和目录\n\n2.创建目录和文件2.1.文件列表lsls,即list，列出目录下的所有项查看当前的目录ls查看/home/niudada目录ls /home/niudada 以详细模式查看ls -l /home/niudada\n\n2.2.显示当前位置pwd :print working diectory显示当前工作目录\n\n2.3.切换目录cdcd : change directory,切换目录切换到某个目录cd /home/niudada/example\n\n2.4.几个特殊的目录~ 当前用户的主目录. 当前目录.. 上一级目录\n\n2.5.目录操作mkdir : make directory 创建目录mkdir abcmkdir -p abc/123/test使用 -p 可以将路径的层次目录全部创建rmdir remove directory 删除空目录rmdir abc  如果目录非空，则删除失败rm remove 删除文件或者目录rm -rf abc 删除abc目录，和子项一并删除cp copy 复制文件或者目录cp -rf example example2mv move 移动文件或目录（重命名）\n\n","tags":["Linux,Ubuntu"]},{"title":"Markdown快速入门","url":"/2022/04/07/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"Markdown快速入门（typora）1.代码块：// 代码块语法​```Java(语言类型)            ​```shell\n\n1.1.java代码块public class HelloWorld &#123;    public static void main(String []args) &#123;        System.out.println(&quot;Hello,World!&quot;);    &#125;&#125;\n\n1.2shell脚本代码块# !/bin/bash  # 脚本生成一个 100 以内的随机数,提示用户猜数字,根据用户的输入,提示用户猜对了,# 猜小了或猜大了,直至用户猜对脚本结束。# RANDOM 为系统自带的系统变量,值为 0‐32767的随机数# 使用取余算法将随机数变为 1‐100 的随机数num=$[RANDOM%100+1]echo &quot;$num&quot; # 使用 read 提示用户猜数字# 使用 if 判断用户猜数字的大小关系:‐eq(等于),‐ne(不等于),‐gt(大于),‐ge(大于等于),# ‐lt(小于),‐le(小于等于)while :  do         read -p &quot;计算机生成了一个 1‐100 的随机数,你猜: &quot; cai        if [ $cai -eq $num ]        then                echo &quot;恭喜,猜对了&quot;                   exit            elif [ $cai -gt $num ]           then                    echo &quot;Oops,猜大了&quot;             else                    echo &quot;Oops,猜小了&quot;         fi  done\n\n2. 标题：// 标题语法# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题    ！**注意：&#x27;#&#x27;与标题之间需要空格隔开**\n\n1级标题2级标题3级标题4级标题5级标题6级标题3.字体：// 加粗**你好，世界**// 代码高亮显示==Hello,World!==// 删除线~~被删除的文字~~// 斜体*斜体*\n\n&#x2F;&#x2F; 加粗你好，世界\n&#x2F;&#x2F; 代码高亮显示Hello,World!\n&#x2F;&#x2F; 删除线被删除的文字\n&#x2F;&#x2F; 斜体斜体\n4.引用：// 引用语法&gt;作责：爱因斯坦&gt;&gt;作责：爱因斯坦&gt;&gt;&gt;作责：爱因斯坦！！！几个尖括号就代表前面有几条竖线。\n\n&#x2F;&#x2F; 引用语法\n\n作责：爱因斯坦\n\n作责：爱因斯坦\n\n作责：爱因斯\n\n\n\n5.分割线：// 分割线方式一：---方式二(此分割线相比方式一较粗，效果如下)：***\n\n6.图片插入：// 在线图片/本地图片![图片名称](/dir/.../..) --图片插入方式(路径为：在线图片连接/本地图片绝对路径)\n\n7.超链接：// 超链接语法[超链接名称](超链接地址)\n\n8.列表：// 无序列表- 无序列表1- 无序列表2- 无序列表3// 有序列表1. 有序列表12. 有序列表22. 有序列表3！**注意：列表符和列表名称之间有空格**\n\n&#x2F;&#x2F; 无序列表\n\n无序列表1\n无序列表2\n无序列表3\n\n&#x2F;&#x2F; 有序列表\n\n有序列表1\n\n有序列表2\n\n有序列表3\n9.表格：右键-&gt;插入-&gt;表格\n\n10.快捷键：// 1.Ctrl + Shift + 1(F1下面的按键) =&gt; 调出文件及大纲栏// 2.Ctrl + / =&gt; 将编辑笔记转换为Markdown编辑语言\n\n","tags":["Markdown"]},{"title":"Hello World","url":"/2022/04/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"位图 位运算实现加减乘除","url":"/2022/05/11/%E4%BD%8D%E5%9B%BE%20%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/","content":"位图 位运算实现加减乘除1.位运算符号~ 取反      ~1=0&amp; 按位与    1&amp;1=1 1&amp;0=0 0&amp;0=0| 按位或    1|1=1 1|0=1 0|0=0^ 按位异或    0^0=0 1^0=1 0^1=1 1^1=0&lt;&lt; 有符号左移  表示向左移动，不分正负数，低位补0&gt;&gt; 有符号右移   表示向右移动，不分正负数，高位补0&gt;&gt;&gt; 无符号右移   正数和有符号右移是没有区别的，唯一有区别的时候是负数的时候，前面会补上1，而不是0\n\n\n\n2.位图一开始定义一个Long类型的数组，使用尽可能少的空间存储更多的数，Long类型是8个字节，一个字节是8bit,也就是说数组中每一个整数，就可以存64个数，当变成1时，表示该数存在，0时表示该数就不存在，当然所存的数时按顺序存储的，以此类推，只要知道要存入的最大值，就可以实现一个比原来数组占用空间至少小64倍的数组，这就是位图\n位图实现1.需要定义一个最大数组 private Long[] bits;        public BitMap(int max) &#123;//            (max + 64) &gt;&gt; 6   -&gt;   (max + 64) / 64            bits = new Long[(max + 64) &gt;&gt; 6];        &#125;\n\n2.添加数\t\tpublic void add(int num) &#123;//           num &gt;&gt; 6 -&gt; num / 64 -&gt; 哪个整数//            num % 64 -&gt; num &amp; 63            bits[num &gt;&gt; 6] |= (1L &lt;&lt; (num &amp; 63));        &#125;\n\n删除某个数public void delete(int num)&#123;    bits[num &gt;&gt; 6] &amp;= ~(1L &lt;&lt; (num &amp; 63));&#125;\n\n查看某个数是否存在public boolean contains(int num) &#123;    return (bits[num &gt;&gt; 6] &amp; (1L &lt;&lt; (num &amp; 63))) != 0;&#125;\n\n整体public class Code02_BitMap2 &#123;    //    public static class BitMap &#123;        private Long[] bits;        public BitMap(int max) &#123;//            (max + 64) &gt;&gt; 6   -&gt;   (max + 64) / 64            bits = new Long[(max + 64) &gt;&gt; 6];        &#125;        public void add(int num) &#123;//           num &gt;&gt; 6 -&gt; num / 64 -&gt; 哪个整数//            num % 64 -&gt; num &amp; 63            bits[num &gt;&gt; 6] |= (1L &lt;&lt; (num &amp; 63));        &#125;        public void delete(int num)&#123;            bits[num &gt;&gt; 6] &amp;= ~(1L &lt;&lt; (num &amp; 63));        &#125;        public boolean contains(int num) &#123;            return (bits[num &gt;&gt; 6] &amp; (1L &lt;&lt; (num &amp; 63))) != 0;        &#125;    &#125;&#125;\n\n\n\n\n\n位运算实现加减乘除java中加减乘除底层原理都是由位运算进行的,手写的用位运算的加减乘除是不如java的加减乘除快的，那是因为手写的还需要进行编译，但是java中的位运算是比加减乘除快的\n加法实现给俩个数a和b 例如\na&#x3D;46 &#x3D;&gt;0101110\nb&#x3D;20&#x3D;&gt;0010100\n首先ab两个数要进行无进位相加，使用按位异或^\n得出\na’&#x3D;0111010\n再用ab两数进行&amp;得出\nb‘&#x3D;0000100, 在进行左移&lt;&lt;\n得出b’&#x3D;0001000\n再用a’和b’进行以上操作，直到b所有位上都是0，此时的a就是a+b的结果\npublic static int add(int a, int b) &#123;       int sum = a;       while(b != 0) &#123;           sum = a ^ b;  //无进位相加信息-&gt; sum           b = (a &amp; b) &lt;&lt; 1;  //进位信息 -&gt; b-&gt;b&#x27;           a = sum;  //a -&gt; a&#x27; 无进位相加信息       &#125;       return sum;   &#125;\n\n减法实现减法实现的原理和加法差不多，就是需要取反一下，剩下的操作和加法一样\n    public static int negNum(int n)&#123;        return add(~n,1); //取反之后+1&#125;    public static int minus(int a, int b) &#123;        return add(a,negNum(b));    &#125;\n\n乘法实现同样也是给出两个数a和b，和小学算术题一样，需要用a每个位乘以b的每个位，然后再加起来\n//    乘法(支持正数负数)    public static int multi(int a, int b) &#123;        int res = 0;        while (b != 0) &#123;            if ((b &amp; 1) != 0)&#123;                res = add(res, a);            &#125;            a &lt;&lt;=1;            b &gt;&gt;&gt;= 1;        &#125;        return res;    &#125;\n\n除法实现需要注意下，有个最小值的问题，当负数的最小值取反时，是无法取到对应的值，所以需要先将这个数加1，再进行相应的做法\n//    除法    public static int div(int a, int b) &#123;        int x = isNeg(a) ? negNum(a) : a;        int y = isNeg(b) ? negNum(b) : b;        int res = 0;//        x / y        for (int i =30; i&gt;= 0; i = minus(i,1)) &#123;            if ((x &gt;&gt; i) &gt;= y) &#123;                res |= (1 &lt;&lt; i);                x = minus(x, y &lt;&lt; i);            &#125;        &#125;        return isNeg(a) != isNeg(b) ? negNum(res) : res;    &#125;//    如果是系统最小值，需要进行判断    public static int divide(int a, int b) &#123;        if (a == Integer.MIN_VALUE &amp;&amp; b == Integer.MIN_VALUE) &#123;            return 1;        &#125;else if (b == Integer.MIN_VALUE)&#123;            return 0;        &#125;else if (a == Integer.MIN_VALUE)&#123;            if (b== negNum(1))&#123;                return Integer.MAX_VALUE;            &#125;else &#123;                /*                * a / b                * (a + 1) / b == c                * a - (b * c) = d                * d / b = e                * c+ e*/                int c = div(add(a, 1), b);                return add(c, div(minus(a, multi(c, b)), b));            &#125;        &#125; else &#123;//            a / b            return div(a, b);        \n\n（左程云视频讲解）\n","tags":["算法,位运算,位图"]},{"url":"/2022/04/08/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","content":""},{"title":"我的第一篇博客","url":"/2022/04/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我的网站搭建安装教程第一步\nTypora\n个人建议在国内的网站上下载\n轻量级文件编辑器\n\n","tags":["web"]}]