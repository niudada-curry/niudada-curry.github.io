[{"title":"MybatisPlus从入门到精通-基础篇","url":"/2022/05/16/01-MybatisPlus-%E5%9F%BA%E7%A1%80%E7%AF%87/","content":"MybatisPlus从入门到精通-基础篇1.概述​     MybatisPlus是一款Mybatis增强工具，用于简化开发，提高效率。  它在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 \n​    官网： https://mp.baomidou.com/ \n2.快速入门2.0 准备工作①准备数据CREATE TABLE `user` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,  `user_name` varchar(20) NOT NULL COMMENT &#x27;用户名&#x27;,  `password` varchar(20) NOT NULL COMMENT &#x27;密码&#x27;,  `name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;,  `age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;,  `address` varchar(100) DEFAULT NULL COMMENT &#x27;地址&#x27;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;insert  into `user`(`id`,`user_name`,`password`,`name`,`age`,`address`) values (1,&#x27;ruiwen&#x27;,&#x27;123&#x27;,&#x27;瑞文&#x27;,12,&#x27;山东&#x27;),(2,&#x27;gailun&#x27;,&#x27;1332&#x27;,&#x27;盖伦&#x27;,13,&#x27;平顶山&#x27;),(3,&#x27;timu&#x27;,&#x27;123&#x27;,&#x27;提姆&#x27;,22,&#x27;蘑菇石&#x27;),(4,&#x27;daji&#x27;,&#x27;1222&#x27;,&#x27;妲己&#x27;,221,&#x27;狐山&#x27;);\n\n②创建SpringBoot工程添加依赖&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.5.0&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建启动类@SpringBootApplicationpublic class SGApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SGApplication.class);    &#125;&#125;\n\n\n\n③准备实体类@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;    private Long id;    private String userName;    private String password;    private String name;    private Integer age;    private String address;&#125;\n\n\n\n2.1 使用MybatisPlus①添加依赖&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n②配置数据库信息spring:  datasource:    url: jdbc:mysql://localhost:3306/mp_db?characterEncoding=utf-8&amp;serverTimezone=UTC    username: root    password: root    driver-class-name: com.mysql.cj.jdbc.Driver\n\n\n\n③创建Mapper接口创建Mapper接口继承BaseMapper接口\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;\n\nBaseMapper接口中已经提供了很多常用方法。所以我们只需要直接从容器中获取Mapper就可以进行操作了，不需要自己去编写Sql语句。\n④配置Mapper扫描​    在启动类上配置我们的Mapper在哪个包。\n@SpringBootApplication@MapperScan(&quot;com.sangeng.mapper&quot;)public class SGApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SGApplication.class,args);    &#125;&#125;\n\n\n\n⑤获取Mapper进行测试@SpringBootTestpublic class MPTest &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testQueryList()&#123;        System.out.println(userMapper.selectList(null));    &#125;&#125;\n\n\n\n\n\n\n\n3.常用设置3.1 设置表映射规则​    默认情况下MP操作的表名就是实体类的类名，但是如果表名和类名不一致就需要我们自己设置映射规则。\n3.1.1 单独设置​    可以在实体类的类名上加上@TableName注解进行标识。\n例如：\n​    如果表名是tb_user，而实体类名是User则可以使用以下写法。\n@TableName(&quot;tb_user&quot;)public class User &#123;\t//....&#125;\n\n\n\n\n\n3.1.2 全局设置表名前缀​    一般一个项目表名的前缀都是统一风格的，这个时候如果一个个设置就太麻烦了。我们可以通过配置来设置全局的表名前缀。\n例如：\n​    如果一个项目中所有的表名相比于类名都是多了个前缀： tb_ 。这可以使用如下方式配置\nmybatis-plus:  global-config:    db-config:      #表名前缀      table-prefix: tb_\n\n\n\n\n\n\n\n3.2 设置主键生成策略3.2.0 测试代码@Testpublic void testInsert()&#123;    User user = new User();    user.setUserName(&quot;三更草堂222&quot;);    user.setPassword(&quot;7777&quot;);    int r = userMapper.insert(user);    System.out.println(r);&#125;\n\n\n\n3.2.1 单独设置​    默认情况下使用MP插入数据时，如果在我们没有设置主键生成策略的情况下默认的策略是基于雪花算法的自增id。\n​    如果我们需要使用别的策略可以在定义实体类时，在代表主键的字段上加上@TableId注解，使用其type属性指定主键生成策略。\n例如：\n​    我们要设置主键自动增长则可以设置如下\n@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;    @TableId(type = IdType.AUTO)    private Long id;\t//.....&#125;\n\n\n\n​    全部主键策略定义在了枚举类IdType中，IdType有如下的取值\n\nAUTO\n数据库ID自增，依赖于数据库。该类型请确保数据库设置了 ID自增 否则无效\n\nNONE\n未设置主键类型。若在代码中没有手动设置主键，则会根据主键的全局策略自动生成（默认的主键全局策略是基于雪花算法的自增ID）\n\nINPUT\n需要手动设置主键，若不设置。插入操作生成SQL语句时，主键这一列的值会是null。\n\nASSIGN_ID\n当没有手动设置主键，即实体类中的主键属性为空时，才会自动填充，使用雪花算法\n\nASSIGN_UUID\n当实体类的主键属性为空时，才会自动填充，使用UUID\n\n\n3.2.2 全局设置mybatis-plus:  global-config:    db-config:      # id生成策略 auto为数据库自增      id-type: auto\n\n\n\n3.3 设置字段映射关系​    默认情况下MP会根据实体类的属性名去映射表的列名。\n​    如果数据库的列表和实体类的属性名不一致了我们可以使用@TableField注解的value属性去设置映射关系。\n​    \n例如：\n​    如果表中一个列名叫 address而 实体类中的属性名为addressStr则可以使用如下方式进行配置。\n@TableField(&quot;address&quot;)private String addressStr;\n\n\n\n3.4 设置字段和列名的驼峰映射​    默认情况下MP会开启字段名列名的驼峰映射， 即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射 。\n​    如果需要关闭我们可以使用如下配置进行关闭。\nmybatis-plus:  configuration:\t#是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射    map-underscore-to-camel-case: false\n\n\n\n\n\n3.5 日志​    如果需要打印MP操作对应的SQL语句等，可以配置日志输出。\n配置方式如下：\nmybatis-plus:  configuration:    # 日志    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n\n\n\n\n4.基本使用4.1 插入数据​    我们可以使用insert方法来实现数据的插入。\n示例：\n@Testpublic void testInsert()&#123;    User user = new User();    user.setUserName(&quot;三更草堂333&quot;);    user.setPassword(&quot;7777888&quot;);    int r = userMapper.insert(user);    System.out.println(r);&#125;\n\n\n\n4.2 删除操作​    我们可以使用deleteXXX方法来实现数据的删除。\n示例：\n@Testpublic void testDelete()&#123;    List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();    ids.add(5);    ids.add(6);    ids.add(7);    int i = userMapper.deleteBatchIds(ids);    System.out.println(i);&#125;@Testpublic void testDeleteById()&#123;    int i = userMapper.deleteById(8);    System.out.println(i);&#125;@Testpublic void testDeleteByMap()&#123;    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;name&quot;,&quot;提姆&quot;);    map.put(&quot;age&quot;,22);    int i = userMapper.deleteByMap(map);    System.out.println(i);&#125;\n\n\n\n\n\n4.3 更新操作​    我们可以使用updateXXX方法来实现数据的删除。\n示例：\n@Testpublic void testUpdate()&#123;    //把id为2的用户的年龄改为14    User user = new User();    user.setId(2L);    user.setAge(14);    int i = userMapper.updateById(user);    System.out.println(i);&#125;\n\n\n\n\n\n\n\n5.条件构造器Wrapper5.1 概述​    我们在实际操作数据库的时候会涉及到很多的条件。所以MP为我们提供了一个功能强大的条件构造器 Wrapper 。使用它可以让我们非常方便的构造条件。\n​    其继承体系如下：\n​    \n​    在其子类AbstractWrapper中提供了很多用于构造Where条件的方法。\n​    AbstractWrapper的子类QueryWrapper则额外提供了用于针对Select语法的select方法。可以用来设置查询哪些列。\n​    AbstractWrapper的子类UpdateWrapper则额外提供了用于针对SET语法的set方法。可以用来设置对哪些列进行更新。\n​    完整的AbstractWrapper方法可以参照：https://baomidou.com/guide/wrapper.html#abstractwrapper\n介绍是用来干什么的。它的实现类有哪些\nQueryWrapper,UpdateWrapper，【LambdaQueryWrapper】\n5.2 常用AbstractWrapper方法\neq：equals，等于gt：greater than ，大于 &gt;ge：greater than or equals，大于等于≥lt：less than，小于&lt;le：less than or equals，小于等于≤between：相当于SQL中的BETWEENlike：模糊匹配。like(“name”,”黄”)，相当于SQL的name like ‘%黄%’likeRight：模糊匹配右半边。likeRight(“name”,”黄”)，相当于SQL的name like ‘黄%’likeLeft：模糊匹配左半边。likeLeft(“name”,”黄”)，相当于SQL的name like ‘%黄’notLike：notLike(“name”,”黄”)，相当于SQL的name not like ‘%黄%’isNullisNotNulland：SQL连接符ANDor：SQL连接符OR\nin: in(“age”,{1,2,3})相当于 age in(1,2,3)\ngroupBy: groupBy(“id”,”name”)相当于 group by id,name\norderByAsc :orderByAsc(“id”,”name”)相当于 order by id ASC,name ASC\norderByDesc :orderByDesc (“id”,”name”)相当于 order by id DESC,name DESC\n\n示例一SQL语句如下： \nSELECT \tid,user_name,PASSWORD,NAME,age,address FROM \tUSER WHERE \tage &gt; 18 AND address = &#x27;狐山&#x27;\n\n如果用Wrapper写法如下：\n@Testpublic void testWrapper01()&#123;    QueryWrapper wrapper = new QueryWrapper();    wrapper.gt(&quot;age&quot;,18);    wrapper.eq(&quot;address&quot;,&quot;狐山&quot;);    List&lt;User&gt; users = userMapper.selectList(wrapper);    System.out.println(users);&#125;\n\n\n\n示例二SQL语句如下：\nSELECT \tid,user_name,PASSWORD,NAME,age,address FROM \tUSER WHERE \tid IN(1,2,3) AND \tage BETWEEN 12 AND 29 AND \taddress LIKE &#x27;%山%&#x27;\n\n\n\n如果用Wrapper写法如下：\n@Testpublic void testWrapper02()&#123;    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.in(&quot;id&quot;,1,2,3);    wrapper.between(&quot;age&quot;,12,29);    wrapper.like(&quot;address&quot;,&quot;山&quot;);    List&lt;User&gt; users = userMapper.selectList(wrapper);    System.out.println(users);&#125;\n\n\n\n示例三SQL语句如下：\nSELECT \tid,user_name,PASSWORD,NAME,age,address FROM \tUSER WHERE \tid IN(1,2,3) AND \tage &gt; 10 ORDER BY \tage DESC\n\n如果用Wrapper写法如下：\n@Testpublic void testWrapper03()&#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.in(&quot;id&quot;,1,2,3);    queryWrapper.gt(&quot;age&quot;,10);    queryWrapper.orderByDesc(&quot;age&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    System.out.println(users);&#125;\n\n\n\n\n\n5.3 常用QueryWrapper方法 QueryWrapper的 select 可以设置要查询的列。\n\n示例一\nselect(String… sqlSelect) 方法的测试为要查询的列名\n\nSQL语句如下：\nSELECT \tid,user_nameFROM \tUSER \n\nMP写法如下：\n@Testpublic void testSelect01()&#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.select(&quot;id&quot;,&quot;user_name&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    System.out.println(users);&#125;\n\n\n\n示例二\nselect(Class entityClass, Predicate predicate)\n\n方法的第一个参数为实体类的字节码对象，第二个参数为Predicate类型，可以使用lambda的写法，过滤要查询的字段 (主键除外) 。\nSQL语句如下：\nSELECT \tid,user_nameFROM \tUSER \n\nMP写法如下：\n@Testpublic void testSelect02()&#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.select(User.class, new Predicate&lt;TableFieldInfo&gt;() &#123;        @Override        public boolean test(TableFieldInfo tableFieldInfo) &#123;            return &quot;user_name&quot;.equals(tableFieldInfo.getColumn());        &#125;    &#125;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    System.out.println(users);&#125;\n\n\n\n\n\n示例三\nselect(Predicate predicate)\n\n方法第一个参数为Predicate类型，可以使用lambda的写法，过滤要查询的字段 (主键除外) 。\nSQL语句如下：\nSELECT \tid,user_name,PASSWORD,NAME,age FROM \tUSER\n\n就是不想查询address这列，其他列都查询了\nMP写法如下：\n@Testpublic void testSelect03()&#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(new User());    queryWrapper.select(new Predicate&lt;TableFieldInfo&gt;() &#123;        @Override        public boolean test(TableFieldInfo tableFieldInfo) &#123;            return !&quot;address&quot;.equals(tableFieldInfo.getColumn());        &#125;    &#125;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    System.out.println(users);&#125;\n\n\n\n\n\n\n\n5.4 常用UpdateWrapper方法​        我们前面在使用update方法时需要创建一个实体类对象传入，用来指定要更新的列及对应的值。但是如果需要更新的列比较少时，创建这么一个对象显的有点麻烦和复杂。\n​        我们可以使用UpdateWrapper的set方法来设置要更新的列及其值。同时这种方式也可以使用Wrapper去指定更复杂的更新条件。\n示例SQL语句如下：\nUPDATE \tUSERSET \tage = 99where \tid &gt; 1\n\n​    我们想把id大于1的用户的年龄修改为99，则可以使用如下写法：\n@Testpublic void testUpdateWrapper()&#123;    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    updateWrapper.gt(&quot;id&quot;,1);    updateWrapper.set(&quot;age&quot;,99);    userMapper.update(null,updateWrapper);&#125;\n\n\n\n\n\n5.5 Lambda条件构造器​    我们前面在使用条件构造器时列名都是用字符串的形式去指定。这种方式无法在编译期确定列名的合法性。\n​    所以MP提供了一个Lambda条件构造器可以让我们直接以实体类的方法引用的形式来指定列名。这样就可以弥补上述缺陷。\n示例要执行的查询对应的SQL如下\nSELECT \tid,user_name,PASSWORD,NAME,age,address FROM \tUSER WHERE \tage &gt; 18 AND address = &#x27;狐山&#x27;\n\n如果使用之前的条件构造器写法如下\n@Testpublic void testLambdaWrapper()&#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper();    queryWrapper.gt(&quot;age&quot;,18);    queryWrapper.eq(&quot;address&quot;,&quot;狐山&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);&#125;\n\n如果使用Lambda条件构造器写法如下\n@Testpublic void testLambdaWrapper2()&#123;    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.gt(User::getAge,18);    queryWrapper.eq(User::getAddress,&quot;狐山&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);&#125;\n\n\n\n\n\n6.自定义SQL​    虽然MP为我们提供了很多常用的方法，并且也提供了条件构造器。但是如果真的遇到了复制的SQL时，我们还是需要自己去定义方法，自己去写对应的SQL，这样SQL也更有利于后期维护。\n​    因为MP是对mybatis做了增强，所以还是支持之前Mybatis的方式去自定义方法。\n​    同时也支持在使用Mybatis的自定义方法时使用MP的条件构造器帮助我们进行条件构造。\n​    接下去我们分别来讲讲。\n6.0 准备工作①准备数据\nCREATE TABLE `orders` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;,  `remark` varchar(100) DEFAULT NULL COMMENT &#x27;备注&#x27;,  `user_id` int(11) DEFAULT NULL COMMENT &#x27;用户id&#x27;,  `update_time` timestamp NULL DEFAULT NULL COMMENT &#x27;更新时间&#x27;,  `create_time` timestamp NULL DEFAULT NULL COMMENT &#x27;创建时间&#x27;,  `version` int(11) DEFAULT &#x27;1&#x27; COMMENT &#x27;版本&#x27;,  `del_flag` int(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除标识,0-未删除,1-已删除&#x27;,  `create_by` varchar(100) DEFAULT NULL COMMENT &#x27;创建人&#x27;,  `update_by` varchar(100) DEFAULT NULL COMMENT &#x27;更新人&#x27;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Data for the table `orders` */insert  into `orders`(`id`,`price`,`remark`,`user_id`,`update_time`,`create_time`,`version`,`del_flag`,`create_by`,`update_by`) values (1,2000,&#x27;无&#x27;,2,&#x27;2021-08-24 21:02:43&#x27;,&#x27;2021-08-24 21:02:46&#x27;,1,0,NULL,NULL),(2,3000,&#x27;无&#x27;,3,&#x27;2021-08-24 21:03:32&#x27;,&#x27;2021-08-24 21:03:35&#x27;,1,0,NULL,NULL),(3,4000,&#x27;无&#x27;,2,&#x27;2021-08-24 21:03:39&#x27;,&#x27;2021-08-24 21:03:41&#x27;,1,0,NULL,NULL);\n\n②创建实体类\n@Data@NoArgsConstructor@AllArgsConstructorpublic class Orders  &#123;    private Long id;    /**     * 价格     */    private Integer price;    /**     * 备注     */    private String remark;    /**     * 用户id     */    private Integer userId;    /**     * 更新时间     */    private LocalDateTime updateTime;    /**     * 创建时间     */    private LocalDateTime createTime;    /**     * 版本     */    private Integer version;    /**     * 逻辑删除标识,0-未删除,1-已删除     */    private Integer delFlag;&#125;\n\n\n\n6.1 Mybatis方式①定义方法​    在Mapper接口中定义方法\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;    User findMyUser(Long id);&#125;\n\n\n\n②创建xml​    先配置xml文件的存放目录\nmybatis-plus:  mapper-locations: classpath*:/mapper/**/*.xml\n\n\n\n​    创建对应的xml映射文件\n③在xml映射文件中编写SQL​    创建对应的标签，编写对应的SQL语句\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;findMyUser&quot; resultType=&quot;com.sangeng.domian.User&quot;&gt;       select * from user where id = #&#123;id&#125;     &lt;/select&gt;&lt;/mapper&gt;\n\n\n\n\n\n\n\n6.2 Mybatis方式结合条件构造器​    我们在使用上述方式自定义方法时。如果也希望我们的自定义方法能像MP自带方法一样使用条件构造器来进行条件构造的话只需要使用如下方式即可。\n①方法定义中添加Warpper类型的参数\n添加Warpper类型的参数，并且要注意给其指定参数名。\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;    User findMyUserByWrapper(@Param(Constants.WRAPPER) Wrapper&lt;User&gt; wrapper);&#125;\n\n\n\n②在SQL语句中获取Warpper拼接的SQL片段进行拼接。\n&lt;select id=&quot;findMyUserByWrapper&quot; resultType=&quot;com.sangeng.domian.User&quot;&gt;    select * from user $&#123;ew.customSqlSegment&#125;&lt;/select&gt;\n\n注意：不能使用#{}应该用${}\n7.分页查询7.1 基本分页查询①配置分页查询拦截器\n@Configurationpublic class PageConfig &#123;    /**     * 3.4.0之前的版本     * @return     */   /* @Bean    public PaginationInterceptor paginationInterceptor()&#123;        return  new PaginationInterceptor();    &#125;*/    /**     * 3.4.0之后版本     * @return     */   @Bean   public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;       MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();       mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());       return mybatisPlusInterceptor;   &#125;&#125;\n\n②进行分页查询\n@Testpublic void testPage()&#123;    IPage&lt;User&gt; page = new Page&lt;&gt;();    //设置每页条数    page.setSize(2);    //设置查询第几页    page.setCurrent(1);    userMapper.selectPage(page, null);    System.out.println(page.getRecords());//获取当前页的数据    System.out.println(page.getTotal());//获取总记录数    System.out.println(page.getCurrent());//当前页码&#125;\n\n\n\n\n\n\n\n7.2 多表分页查询​    如果需要在多表查询时进行分页查询的话，就可以在mapper接口中自定义方法，然后让方法接收Page对象。\n示例需求​    我们需要去查询Orders表，并且要求查询的时候除了要获取到Orders表中的字段，还要获取到每个订单的下单用户的用户名。\n准备工作SQL准备SELECT \to.*,u.`user_name`FROM \tUSER u,orders oWHERE \to.`user_id` = u.`id`\n\n实体类修改增加一个userName属性\n@Data@NoArgsConstructor@AllArgsConstructorpublic class Orders  &#123;\t//省略无关代码    private String userName;&#125;\n\n\n\n实现①定义接口，定义方法\n方法第一个测试定义成Page类型\npublic interface OrdersMapper extends BaseMapper&lt;Orders&gt; &#123;    IPage&lt;Orders&gt; findAllOrders(Page&lt;Orders&gt; page);&#125;\n\n\n在xml中不需要关心分页操作，MP会帮我们完成。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.OrdersMapper&quot;&gt;    &lt;select id=&quot;findAllOrders&quot; resultType=&quot;com.sangeng.domian.Orders&quot;&gt;        SELECT            o.*,u.`user_name`        FROM            USER u,orders o        WHERE            o.`user_id` = u.`id`    &lt;/select&gt;&lt;/mapper&gt;\n\n然后调用方法测试即可\n@Autowiredprivate OrdersMapper ordersMapper;@Testpublic void testOrdersPage()&#123;    Page&lt;Orders&gt; page = new Page&lt;&gt;();    //设置每页大小    page.setSize(2);    //设置当前页码    page.setCurrent(2);    ordersMapper.findAllOrders(page);    System.out.println(page.getRecords());    System.out.println(page.getTotal());&#125;\n\n\n\n\n\n8.Service 层接口​    MP也为我们提供了Service层的实现。我们只需要编写一个接口，继承IService，并创建一个接口实现类继承ServiceImpl，即可使用。\n​    相比于Mapper接口，Service层主要是支持了更多批量操作的方法。\n8.1 基本使用8.1.1 改造前定义接口\npublic interface UserService &#123;    List&lt;User&gt; list();&#125;\n\n定义实现类\n@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserMapper userMapper;    @Override    public List&lt;User&gt; list() &#123;        return userMapper.selectList(null);    &#125;&#125;\n\n\n\n8.1.2 改造后接口\npublic interface UserService extends IService&lt;User&gt; &#123;&#125;\n\n实现类\n@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;\t&#125;\n\n测试\n@Autowiredprivate UserService userService;@Testpublic void testSeervice()&#123;    List&lt;User&gt; list = userService.list();    System.out.println(list);&#125;\n\n\n\n8.2自定义方法public interface UserService extends IService&lt;User&gt; &#123;    User test();&#125;\n\n@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;    @Autowired    private OrdersMapper ordersMapper;    @Override    public User test() &#123;        UserMapper userMapper = getBaseMapper();        List&lt;Orders&gt; orders = ordersMapper.selectList(null);        User user = userMapper.selectById(3);        //查询用户对于的订单        QueryWrapper&lt;Orders&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;user_id&quot;,3);        List&lt;Orders&gt; ordersList = ordersMapper.selectList(wrapper);        return user;    &#125;&#125;\n\n\n\n\n\n\n\n9.代码生成器​    MP提供了一个代码生成器，可以让我们一键生成实体类，Mapper接口，Service，Controller等全套代码 。使用方式如下\n①添加依赖&lt;!--mybatisplus代码生成器--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--模板引擎--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n②生成​    修改相应配置后执行以下代码即可\npublic class GeneratorTest &#123;\t@Test\tpublic void generate() &#123;\t\tAutoGenerator generator = new AutoGenerator();\t\t// 全局配置\t\tGlobalConfig config = new GlobalConfig();\t\tString projectPath = System.getProperty(&quot;user.dir&quot;);\t\t// 设置输出到的目录\t\tconfig.setOutputDir(projectPath + &quot;/src/main/java&quot;);\t\tconfig.setAuthor(&quot;sangeng&quot;);\t\t// 生成结束后是否打开文件夹\t\tconfig.setOpen(false);\t\t// 全局配置添加到 generator 上\t\tgenerator.setGlobalConfig(config);\t\t// 数据源配置\t\tDataSourceConfig dataSourceConfig = new DataSourceConfig();\t\tdataSourceConfig.setUrl(&quot;jdbc:mysql://localhost:3306/mp_db?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;);\t\tdataSourceConfig.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);\t\tdataSourceConfig.setUsername(&quot;root&quot;);\t\tdataSourceConfig.setPassword(&quot;root&quot;);\t\t// 数据源配置添加到 generator\t\tgenerator.setDataSource(dataSourceConfig);\t\t// 包配置, 生成的代码放在哪个包下\t\tPackageConfig packageConfig = new PackageConfig();\t\tpackageConfig.setParent(&quot;com.sangeng.mp.generator&quot;);\t\t// 包配置添加到 generator\t\tgenerator.setPackageInfo(packageConfig);\t\t// 策略配置\t\tStrategyConfig strategyConfig = new StrategyConfig();\t\t// 下划线驼峰命名转换\t\tstrategyConfig.setNaming(NamingStrategy.underline_to_camel);\t\tstrategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);\t\t// 开启lombok\t\tstrategyConfig.setEntityLombokModel(true);\t\t// 开启RestController\t\tstrategyConfig.setRestControllerStyle(true);\t\tgenerator.setStrategy(strategyConfig);\t\tgenerator.setTemplateEngine(new FreemarkerTemplateEngine());        // 开始生成\t\tgenerator.execute();\t&#125;&#125;\n\n","tags":["MybatisPlus"]},{"title":"MybatisPlus从入门到精通-高级篇","url":"/2022/05/16/02-MybatisPlus-%E9%AB%98%E7%BA%A7%E7%AF%87/","content":"MybatisPlus从入门到精通-高级篇1.自动填充​    在实际项目中的表会和我们的orders表一样，有更新时间，创建时间，创建人，更新人等字段。\n​    我们可以使用 @TableField 的 fill  属性来设置字段的自动填充。让我们能更方便的更新相关字段。\n示例①在对应字段上增加注解\n​    使用TableField注解的fill属性来标注哪些字段需要在自动填充，加了注解MP才会在对应的SQL中为我们预留字段。而属性值代表我们在什么进行什么操作时需要预留字段。\n/** * 更新时间 */@TableField(fill = FieldFill.INSERT_UPDATE)private LocalDateTime updateTime;/** * 创建时间 */@TableField(fill = FieldFill.INSERT)private LocalDateTime createTime;\n\n\n\n\n\n②自定义填充处理器  MetaObjectHandler \n@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;createTime&quot;, LocalDateTime.now(), metaObject);        this.setFieldValByName(&quot;updateTime&quot;, LocalDateTime.now(), metaObject);    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;updateTime&quot;, LocalDateTime.now(), metaObject);    &#125;&#125;\n\n​    \n2.逻辑删除​    MP也支持逻辑删除的处理。我们只需要配置好逻辑删除的实体字段名，代表删除的字段值和代表未删除的字段值后即可。\n​    注意：如果3.3.0版本之前还需要在对应的字段上加上@TableLogic注解\nmybatis-plus:  global-config:    db-config:      logic-delete-field: delFlag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)      logic-delete-value: 1 # 逻辑已删除值(默认为 1)      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n\n\n\n\n\n\n\n\n\n3.乐观锁​    并发操作时,我们需要保证对数据的操作不发生冲突。乐观锁就是其中一种方式。乐观锁就是先加上不存在并发冲突问题，在进行实际数据操作的时候再检查是否冲突。\n​    我们在使用乐观锁时一般在表中增加一个version列。用来记录我们对每天记录操作的版本。每次对某条记录进行过操作是，对应的版本也需要+1。\n​    然后我们在每次要进行更新操作时，先查询对应数据的version值。在执行更新时， set version &#x3D; 老版本+1 where version &#x3D; 老版本 \n​    如果在查询老版本号到更新操作的中间时刻有其他人更新了这条数据，这样这次更新语句就会更新失败。\n​    这里在更新时对version的操作如果有我们自己做就会显的有点麻烦。所以MP提供了乐观锁插件。\n​    使用后我们就可以非常方便的实现对version的操作。\n3.1 使用①配置对应插件\n@Configurationpublic class MybatisPlusConfig &#123;    /**     * 旧版     */    @Bean    public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;        return new OptimisticLockerInterceptor();    &#125;        /**     * 新版     */    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());        return mybatisPlusInterceptor;    &#125;&#125;\n\n\n\n②在实体类的字段上加上@Version注解\n@Versionprivate Integer version;\n\n③更新\n注意：在更新前我们一定要先查询到version设置到实体类上再进行更新才能生效\n@Testpublic void testVersion()&#123;    //查询id为3的数据    QueryWrapper&lt;Orders&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.eq(&quot;id&quot;,3);    Orders orders = ordersMapper.selectOne(queryWrapper);    //对id为3的数据进行更新  把price修改为88    orders.setPrice(88);    ordersMapper.updateById(orders);&#125;\n\n这种情况下我们可以看到执行的sql已经发生了变化。\n==&gt;  Preparing: UPDATE orders SET price=?, update_time=?, version=? WHERE id=? AND version=? AND del_flag=0==&gt; Parameters: 8888(Integer), null, 2(Integer), 2(Long), 1(Integer)\n\n\n\n\n\n3.2 多插件配置问题​    我们在使用3.4.0版本以后的MP时，如果需要用到多个插件的话要注意。在配置的时候只需要注入一个MybatisPlusInterceptor 对象，把插件对象添加到MybatisPlusInterceptor 对象中即可。\n​    例如：\n@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123;    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());    return interceptor;&#125;\n\n\n\n","tags":["MybatisPlus"]},{"title":"Markdown快速入门","url":"/2022/04/07/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"Markdown快速入门（typora）1.代码块：// 代码块语法​```Java(语言类型)            ​```shell\n\n1.1.java代码块public class HelloWorld &#123;    public static void main(String []args) &#123;        System.out.println(&quot;Hello,World!&quot;);    &#125;&#125;\n\n1.2shell脚本代码块# !/bin/bash  # 脚本生成一个 100 以内的随机数,提示用户猜数字,根据用户的输入,提示用户猜对了,# 猜小了或猜大了,直至用户猜对脚本结束。# RANDOM 为系统自带的系统变量,值为 0‐32767的随机数# 使用取余算法将随机数变为 1‐100 的随机数num=$[RANDOM%100+1]echo &quot;$num&quot; # 使用 read 提示用户猜数字# 使用 if 判断用户猜数字的大小关系:‐eq(等于),‐ne(不等于),‐gt(大于),‐ge(大于等于),# ‐lt(小于),‐le(小于等于)while :  do         read -p &quot;计算机生成了一个 1‐100 的随机数,你猜: &quot; cai        if [ $cai -eq $num ]        then                echo &quot;恭喜,猜对了&quot;                   exit            elif [ $cai -gt $num ]           then                    echo &quot;Oops,猜大了&quot;             else                    echo &quot;Oops,猜小了&quot;         fi  done\n\n2. 标题：// 标题语法# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题    ！**注意：&#x27;#&#x27;与标题之间需要空格隔开**\n\n1级标题2级标题3级标题4级标题5级标题6级标题3.字体：// 加粗**你好，世界**// 代码高亮显示==Hello,World!==// 删除线~~被删除的文字~~// 斜体*斜体*\n\n&#x2F;&#x2F; 加粗你好，世界\n&#x2F;&#x2F; 代码高亮显示Hello,World!\n&#x2F;&#x2F; 删除线被删除的文字\n&#x2F;&#x2F; 斜体斜体\n4.引用：// 引用语法&gt;作责：爱因斯坦&gt;&gt;作责：爱因斯坦&gt;&gt;&gt;作责：爱因斯坦！！！几个尖括号就代表前面有几条竖线。\n\n&#x2F;&#x2F; 引用语法\n\n作责：爱因斯坦\n\n作责：爱因斯坦\n\n作责：爱因斯\n\n\n\n5.分割线：// 分割线方式一：---方式二(此分割线相比方式一较粗，效果如下)：***\n\n6.图片插入：// 在线图片/本地图片![图片名称](/dir/.../..) --图片插入方式(路径为：在线图片连接/本地图片绝对路径)\n\n7.超链接：// 超链接语法[超链接名称](超链接地址)\n\n8.列表：// 无序列表- 无序列表1- 无序列表2- 无序列表3// 有序列表1. 有序列表12. 有序列表22. 有序列表3！**注意：列表符和列表名称之间有空格**\n\n&#x2F;&#x2F; 无序列表\n\n无序列表1\n无序列表2\n无序列表3\n\n&#x2F;&#x2F; 有序列表\n\n有序列表1\n\n有序列表2\n\n有序列表3\n9.表格：右键-&gt;插入-&gt;表格\n\n10.快捷键：// 1.Ctrl + Shift + 1(F1下面的按键) =&gt; 调出文件及大纲栏// 2.Ctrl + / =&gt; 将编辑笔记转换为Markdown编辑语言\n\n","tags":["Markdown"]},{"title":"Ubuntu","url":"/2022/04/30/Ubuntu%E7%B3%BB%E7%BB%9F/","content":"Ubuntu系统1.1.1.文件系统linux,使用统一的目录树结构\n//home/niudada/root/bin/mnt/usr/etc\n\n注意：linux下没有C:D:盘符的概念\n1.2.用户目录/home/niudada 称为niudada的用户目录linux系统支持多个用户，每个用户一个目录都有一个超级用户root，其用户目录为/rootroot用户没有限制，可以操作任意文件和目录\n\n2.创建目录和文件2.1.文件列表lsls,即list，列出目录下的所有项查看当前的目录ls查看/home/niudada目录ls /home/niudada 以详细模式查看ls -l /home/niudada\n\n2.2.显示当前位置pwd :print working diectory显示当前工作目录\n\n2.3.切换目录cdcd : change directory,切换目录切换到某个目录cd /home/niudada/example\n\n2.4.几个特殊的目录~ 当前用户的主目录. 当前目录.. 上一级目录\n\n2.5.目录操作mkdir : make directory 创建目录mkdir abcmkdir -p abc/123/test使用 -p 可以将路径的层次目录全部创建rmdir remove directory 删除空目录rmdir abc  如果目录非空，则删除失败rm remove 删除文件或者目录rm -rf abc 删除abc目录，和子项一并删除cp copy 复制文件或者目录cp -rf example example2mv move 移动文件或目录（重命名）\n\n","tags":["Linux,Ubuntu"]},{"title":"Hello World","url":"/2022/04/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"位图 位运算实现加减乘除","url":"/2022/05/11/%E4%BD%8D%E5%9B%BE%20%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/","content":"位图 位运算实现加减乘除1.位运算符号~ 取反      ~1=0&amp; 按位与    1&amp;1=1 1&amp;0=0 0&amp;0=0| 按位或    1|1=1 1|0=1 0|0=0^ 按位异或    0^0=0 1^0=1 0^1=1 1^1=0&lt;&lt; 有符号左移  表示向左移动，不分正负数，低位补0&gt;&gt; 有符号右移   表示向右移动，不分正负数，高位补0&gt;&gt;&gt; 无符号右移   正数和有符号右移是没有区别的，唯一有区别的时候是负数的时候，前面会补上1，而不是0\n\n\n\n2.位图一开始定义一个Long类型的数组，使用尽可能少的空间存储更多的数，Long类型是8个字节，一个字节是8bit,也就是说数组中每一个整数，就可以存64个数，当变成1时，表示该数存在，0时表示该数就不存在，当然所存的数时按顺序存储的，以此类推，只要知道要存入的最大值，就可以实现一个比原来数组占用空间至少小64倍的数组，这就是位图\n位图实现1.需要定义一个最大数组 private Long[] bits;        public BitMap(int max) &#123;//            (max + 64) &gt;&gt; 6   -&gt;   (max + 64) / 64            bits = new Long[(max + 64) &gt;&gt; 6];        &#125;\n\n2.添加数\t\tpublic void add(int num) &#123;//           num &gt;&gt; 6 -&gt; num / 64 -&gt; 哪个整数//            num % 64 -&gt; num &amp; 63            bits[num &gt;&gt; 6] |= (1L &lt;&lt; (num &amp; 63));        &#125;\n\n删除某个数public void delete(int num)&#123;    bits[num &gt;&gt; 6] &amp;= ~(1L &lt;&lt; (num &amp; 63));&#125;\n\n查看某个数是否存在public boolean contains(int num) &#123;    return (bits[num &gt;&gt; 6] &amp; (1L &lt;&lt; (num &amp; 63))) != 0;&#125;\n\n整体public class Code02_BitMap2 &#123;    //    public static class BitMap &#123;        private Long[] bits;        public BitMap(int max) &#123;//            (max + 64) &gt;&gt; 6   -&gt;   (max + 64) / 64            bits = new Long[(max + 64) &gt;&gt; 6];        &#125;        public void add(int num) &#123;//           num &gt;&gt; 6 -&gt; num / 64 -&gt; 哪个整数//            num % 64 -&gt; num &amp; 63            bits[num &gt;&gt; 6] |= (1L &lt;&lt; (num &amp; 63));        &#125;        public void delete(int num)&#123;            bits[num &gt;&gt; 6] &amp;= ~(1L &lt;&lt; (num &amp; 63));        &#125;        public boolean contains(int num) &#123;            return (bits[num &gt;&gt; 6] &amp; (1L &lt;&lt; (num &amp; 63))) != 0;        &#125;    &#125;&#125;\n\n\n\n\n\n位运算实现加减乘除java中加减乘除底层原理都是由位运算进行的,手写的用位运算的加减乘除是不如java的加减乘除快的，那是因为手写的还需要进行编译，但是java中的位运算是比加减乘除快的\n加法实现给俩个数a和b 例如\na&#x3D;46 &#x3D;&gt;0101110\nb&#x3D;20&#x3D;&gt;0010100\n首先ab两个数要进行无进位相加，使用按位异或^\n得出\na’&#x3D;0111010\n再用ab两数进行&amp;得出\nb‘&#x3D;0000100, 在进行左移&lt;&lt;\n得出b’&#x3D;0001000\n再用a’和b’进行以上操作，直到b所有位上都是0，此时的a就是a+b的结果\npublic static int add(int a, int b) &#123;       int sum = a;       while(b != 0) &#123;           sum = a ^ b;  //无进位相加信息-&gt; sum           b = (a &amp; b) &lt;&lt; 1;  //进位信息 -&gt; b-&gt;b&#x27;           a = sum;  //a -&gt; a&#x27; 无进位相加信息       &#125;       return sum;   &#125;\n\n减法实现减法实现的原理和加法差不多，就是需要取反一下，剩下的操作和加法一样\n    public static int negNum(int n)&#123;        return add(~n,1); //取反之后+1&#125;    public static int minus(int a, int b) &#123;        return add(a,negNum(b));    &#125;\n\n乘法实现同样也是给出两个数a和b，和小学算术题一样，需要用a每个位乘以b的每个位，然后再加起来\n//    乘法(支持正数负数)    public static int multi(int a, int b) &#123;        int res = 0;        while (b != 0) &#123;            if ((b &amp; 1) != 0)&#123;                res = add(res, a);            &#125;            a &lt;&lt;=1;            b &gt;&gt;&gt;= 1;        &#125;        return res;    &#125;\n\n除法实现需要注意下，有个最小值的问题，当负数的最小值取反时，是无法取到对应的值，所以需要先将这个数加1，再进行相应的做法\n//    除法    public static int div(int a, int b) &#123;        int x = isNeg(a) ? negNum(a) : a;        int y = isNeg(b) ? negNum(b) : b;        int res = 0;//        x / y        for (int i =30; i&gt;= 0; i = minus(i,1)) &#123;            if ((x &gt;&gt; i) &gt;= y) &#123;                res |= (1 &lt;&lt; i);                x = minus(x, y &lt;&lt; i);            &#125;        &#125;        return isNeg(a) != isNeg(b) ? negNum(res) : res;    &#125;//    如果是系统最小值，需要进行判断    public static int divide(int a, int b) &#123;        if (a == Integer.MIN_VALUE &amp;&amp; b == Integer.MIN_VALUE) &#123;            return 1;        &#125;else if (b == Integer.MIN_VALUE)&#123;            return 0;        &#125;else if (a == Integer.MIN_VALUE)&#123;            if (b== negNum(1))&#123;                return Integer.MAX_VALUE;            &#125;else &#123;                /*                * a / b                * (a + 1) / b == c                * a - (b * c) = d                * d / b = e                * c+ e*/                int c = div(add(a, 1), b);                return add(c, div(minus(a, multi(c, b)), b));            &#125;        &#125; else &#123;//            a / b            return div(a, b);        \n\n（左程云视频讲解）\n","tags":["算法,位运算,位图"]},{"url":"/2022/04/08/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","content":""},{"title":"我的第一篇博客","url":"/2022/04/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我的网站搭建安装教程第一步\nTypora\n个人建议在国内的网站上下载\n轻量级文件编辑器\n\n","tags":["web"]}]